Here is a GCP-compatible Terraform configuration and Python client code based on your YAML. It provisions a Pub/Sub topic (myQueue), a dead-letter topic (myDLQ), and a subscription with a DLQ and a configurable ack deadline. It also includes Python code using google-cloud-pubsub to publish, pull, acknowledge, and modify visibility (ack deadline).

Notes about mapping your YAML:
- name: myQueue -> Pub/Sub topic: myQueue
- dlq_name: myDLQ -> Dead-letter topic: myDLQ
- number_of_retries: 5 -> max_delivery_attempts on the DLQ policy
- visibility_timeout: 30 -> ack_deadline_seconds on the subscription
- type: standard or FIFO
  - If FIFO, message ordering is enabled on the topic (enable_message_ordering = true)
  - If standard, ordering is disabled
- metadata: "project: cloud-abstractor, env: dev" -> applied as labels on resources
- size: 262144 is not directly applicable to Pub/Sub; not used in Terraform or Python

Terraform (GCP Pub/SubProvisioning)
- Assumes the GCP project is cloud-abstractor
- Uses the DLQ myDLQ and the main queue myQueue
- Applies labels from metadata
- Enables ordering only for FIFO

Terraform code (main.tf)
------------------------------------------------------------
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 4.0"
    }
  }
  required_version = ">= 0.14"
}

provider "google" {
  project = "cloud-abstractor"
  # region is not required for Pub/Sub, but you can set it if desired
  # region = "us-central1"
}

# Optional: allow choosing FIFO vs Standard via a variable
variable "queue_type" {
  type    = string
  default = "standard" # set to "FIFO" to enable ordering
}

# Topic: main queue
resource "google_pubsub_topic" "queue" {
  name = "myQueue"

  # Enable message ordering only for FIFO
  enable_message_ordering = var.queue_type == "FIFO" ? true : false

  labels = {
    project = "cloud-abstractor"
    env     = "dev"
  }
}

# Dead-letter topic
resource "google_pubsub_topic" "dlq" {
  name = "myDLQ"

  labels = {
    project = "cloud-abstractor"
    env     = "dev"
  }
}

# Subscription for the main topic with DLQ policy and ack deadline
resource "google_pubsub_subscription" "queue_sub" {
  name  = "myQueue-subscription"
  topic = google_pubsub_topic.queue.id

  # Visibility timeout (ack deadline)
  ack_deadline_seconds = 30

  # Dead-letter policy
  dead_letter_policy {
    dead_letter_topic       = google_pubsub_topic.dlq.id
    max_delivery_attempts   = 5
  }

  labels = {
    project = "cloud-abstractor"
    env     = "dev"
  }
}
------------------------------------------------------------

Python client code (google-cloud-pubsub)
- Provides functions to publish messages, pull/get messages, acknowledge (delete) messages, and change visibility timeout (ack deadline)
- Assumes a single topic myQueue and a subscription myQueue-subscription
- If FIFO is desired, publish with an ordering_key to ensure ordering
- Install: pip install google-cloud-pubsub

Python code (pubsub_queue.py)
------------------------------------------------------------
#!/usr/bin/env python3
"""
Pub/Sub queue interaction:
- publish_message: add a message to the queue (optionally with an ordering_key for FIFO)
- get_message: pull messages from the subscription (returns data and ack_ids)
- delete_message: acknowledge a specific message (delete it from the queue)
- change_visibility_timeout: modify the ACK deadline for specific message(s)
"""

from google.cloud import pubsub_v1
from typing import List, Tuple, Optional

PROJECT_ID = "cloud-abstractor"
TOPIC_ID = "myQueue"
SUBSCRIPTION_ID = "myQueue-subscription"
DLQ_TOPIC_ID = "myDLQ"  # for reference

publisher = pubsub_v1.PublisherClient()
subscriber = pubsub_v1.SubscriberClient()

topic_path = publisher.topic_path(PROJECT_ID, TOPIC_ID)
subscription_path = subscriber.subscription_path(PROJECT_ID, SUBSCRIPTION_ID)

def publish_message(message: str, ordering_key: Optional[str] = None) -> str:
    """Publish a message to the queue. Use ordering_key for FIFO ordering."""
    data = message.encode("utf-8")
    if ordering_key:
        future = publisher.publish(topic_path, data, ordering_key=ordering_key)
    else:
        future = publisher.publish(topic_path, data)
    message_id = future.result()
    print(f"Published message with ID: {message_id}")
    return message_id

def get_messages(max_messages: int = 1) -> List[Tuple[str, str]]:
    """
    Pull messages from the subscription.
    Returns a list of tuples: (message_data_str, ack_id)
    Note: This function does not ack messages automatically; use delete_message to ack.
    """
    response = subscriber.pull(request={"subscription": subscription_path, "max_messages": max_messages})
    results = []
    ack_ids = []
    for received in response.received_messages:
        data = received.message.data.decode("utf-8")
        ack_id = received.ack_id
        results.append((data, ack_id))
        ack_ids.append(ack_id)
        print(f"Pulled message: {data} (ack_id={ack_id})")
    if ack_ids:
        # Return ack_ids for manual ack later if desired
        pass
    return results

def delete_message(ack_id: str) -> None:
    """Ack (delete) a single message by its ack_id."""
    subscriber.acknowledge(request={"subscription": subscription_path, "ack_ids": [ack_id]})
    print(f"Acknowledged (deleted) message with ack_id: {ack_id}")

def change_visibility_timeout(ack_id: str, seconds: int) -> None:
    """Change the visibility timeout (ACK deadline) for a specific message."""
    subscriber.modify_ack_deadline(
        request={
            "subscription": subscription_path,
            "ack_ids": [ack_id],
            "ack_deadline_seconds": seconds,
        }
    )
    print(f"Set ack deadline to {seconds} seconds for ack_id: {ack_id}")

# Example usage (uncomment to run):
# if __name__ == "__main__":
#     publish_message("Hello, Pub/Sub!", ordering_key="order-1")  # Use ordering_key for FIFO if enabled
#     msgs = get_messages(max_messages=1)
#     if msgs:
#         data, ack_id = msgs[0]
#         print(f"Processing: {data}")
#         delete_message(ack_id)
#     # Change visibility timeout example (after receiving an ack_id from get_messages)
#     # change_visibility_timeout(ack_id, 60)
------------------------------------------------------------

What to customize if needed
- Project: The Terraform provider block and variable PROJECT_ID should be set to your actual GCP project ID. The example uses cloud-abstractor as per the YAML metadata.
- queue_type: Set var.queue_type to "FIFO" if you want to enable message ordering (true for FIFO, false for standard).
- Labels: metadata from YAML (project and env) are applied as labels on the Pub/Sub resources. You can expand this by parsing more key-value pairs if needed.
- Size: The YAML size value is not directly used in Pub/Sub. If you have a size-related constraint (e.g., max message size), Pub/Sub supports message payloads up to 10 MB; for larger requirements consider chunking or alternative storage.

Would you like me to tailor the Terraform and Python code to a specific Terraform workspace structure (modules, workspaces, or CI/CD) or adjust the Python code to expose a simple CLI for publish/get/ack operations?